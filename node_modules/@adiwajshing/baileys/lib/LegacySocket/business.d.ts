import { LegacySocketConfig, OrderDetails } from '../Types';
import { Product, ProductCreate, ProductUpdate } from '../Types';
declare const makeBusinessSocket: (config: LegacySocketConfig) => {
    getOrderDetails: (orderId: string, tokenBase64: string) => Promise<OrderDetails>;
    getCatalog: (jid?: string, limit?: number) => Promise<{
        beforeCursor: string;
        products: Product[];
    }>;
    productCreate: (product: ProductCreate) => Promise<Product>;
    productDelete: (productIds: string[]) => Promise<{
        deleted: any;
    }>;
    productUpdate: (productId: string, update: ProductUpdate) => Promise<Product>;
    groupMetadata: (jid: string, minimal: boolean) => Promise<import("@adiwajshing/baileys/src/Types/GroupMetadata").GroupMetadata>;
    groupCreate: (title: string, participants: string[]) => Promise<import("@adiwajshing/baileys/src/Types/GroupMetadata").GroupMetadata>;
    groupLeave: (id: string) => Promise<void>;
    groupUpdateSubject: (id: string, title: string) => Promise<void>;
    groupUpdateDescription: (jid: string, description: string) => Promise<{
        status: number;
    }>;
    groupParticipantsUpdate: (id: string, participants: string[], action: import("@adiwajshing/baileys/src/Types/GroupMetadata").ParticipantAction) => Promise<string[]>;
    getBroadcastListInfo: (jid: string) => Promise<import("@adiwajshing/baileys/src/Types/GroupMetadata").GroupMetadata>;
    groupInviteCode: (jid: string) => Promise<string>;
    relayMessage: (message: import("@adiwajshing/baileys/WAProto").proto.IWebMessageInfo, { waitForAck }?: {
        waitForAck: boolean;
    }) => Promise<void>;
    waUploadToServer: import("@adiwajshing/baileys/src/Types/Message").WAMediaUploadFunction;
    generateUrlInfo: (text: string) => Promise<import("@adiwajshing/baileys/src/Types/Message").WAUrlInfo>;
    messageInfo: (jid: string, messageID: string) => Promise<import("@adiwajshing/baileys/WAProto").proto.IUserReceipt[]>;
    downloadMediaMessage: (message: import("@adiwajshing/baileys/WAProto").proto.IWebMessageInfo, type?: "buffer" | "stream", options?: import("@adiwajshing/baileys/src").MediaDownloadOptions) => Promise<any>;
    updateMediaMessage: (message: import("@adiwajshing/baileys/WAProto").proto.IWebMessageInfo) => Promise<import("@adiwajshing/baileys/src").BinaryNode>;
    fetchMessagesFromWA: (jid: string, count: number, cursor?: import("@adiwajshing/baileys/src/Types/Message").WAMessageCursor) => Promise<import("@adiwajshing/baileys/WAProto").proto.WebMessageInfo[]>;
    loadMessageFromWA: (jid: string, id: string) => Promise<import("@adiwajshing/baileys/WAProto").proto.WebMessageInfo>;
    searchMessages: (txt: string, inJid: string, count: number, page: number) => Promise<{
        last: boolean;
        messages: import("@adiwajshing/baileys/WAProto").proto.WebMessageInfo[];
    }>;
    sendMessage: (jid: string, content: import("@adiwajshing/baileys/src/Types/Message").AnyMessageContent, options?: import("@adiwajshing/baileys/src/Types/Message").MiscMessageGenerationOptions & {
        waitForAck?: boolean;
    }) => Promise<import("@adiwajshing/baileys/WAProto").proto.WebMessageInfo>;
    sendChatsQuery: (epoch: number) => Promise<string>;
    profilePictureUrl: (jid: string, timeoutMs?: number) => Promise<string>;
    chatRead: (fromMessage: import("@adiwajshing/baileys/WAProto").proto.IMessageKey, count: number) => Promise<void>;
    chatModify: (modification: import("@adiwajshing/baileys/src/Types/Chat").ChatModification, jid: string, chatInfo: Pick<import("@adiwajshing/baileys/src/Types/Chat").Chat, "mute" | "pin">, timestampNow?: number) => Promise<void | {
        status: number;
    }>;
    onWhatsApp: (str: string) => Promise<{
        exists: boolean;
        jid: string;
        isBusiness: boolean;
    }>;
    sendPresenceUpdate: (type: import("@adiwajshing/baileys/src/Types/Chat").WAPresence, toJid?: string) => Promise<string>;
    presenceSubscribe: (jid: string) => Promise<string>;
    getStatus: (jid: string) => Promise<{
        status: string;
    }>;
    setStatus: (status: string) => Promise<{
        status: number;
    }>;
    updateBusinessProfile: (profile: import("../Types").WABusinessProfile) => Promise<void>;
    updateProfileName: (name: string) => Promise<{
        status: number;
        pushname: string;
    }>;
    updateProfilePicture(jid: string, img: Buffer): Promise<void>;
    blockUser: (jid: string, type?: "add" | "remove") => Promise<void>;
    getBusinessProfile: (jid: string) => Promise<import("../Types").WABusinessProfile>;
    state: import("@adiwajshing/baileys/src/Types/State").ConnectionState;
    authInfo: import("@adiwajshing/baileys/src/Types/Legacy").LegacyAuthenticationCreds;
    ev: import("@adiwajshing/baileys/src/Types/Legacy").LegacyBaileysEventEmitter;
    canLogin: () => boolean;
    logout: () => Promise<void>;
    waitForConnectionUpdate: (check: (u: Partial<import("@adiwajshing/baileys/src/Types/State").ConnectionState>) => boolean, timeoutMs?: number) => Promise<void>;
    type: "legacy";
    ws: any;
    sendAdminTest: () => Promise<string>;
    updateKeys: (info: {
        encKey: Buffer;
        macKey: Buffer;
    }) => {
        encKey: Buffer;
        macKey: Buffer;
    };
    waitForSocketOpen: () => Promise<void>;
    sendNode: ({ json, binaryTag, tag, longTag }: import("@adiwajshing/baileys/src/Types/Legacy").SocketSendMessageOptions) => Promise<string>;
    generateMessageTag: (longTag?: boolean) => string;
    waitForMessage: (tag: string, requiresPhoneConnection: boolean, timeoutMs?: number) => {
        promise: Promise<any>;
        cancelToken: () => void;
    };
    query: ({ json, timeoutMs, expect200, tag, longTag, binaryTag, requiresPhoneConnection }: import("@adiwajshing/baileys/src/Types/Legacy").SocketQueryOptions) => Promise<any>;
    setQuery: (nodes: import("@adiwajshing/baileys/src").BinaryNode[], binaryTag?: import("@adiwajshing/baileys/src/Types/Legacy").WATag, tag?: string) => Promise<{
        status: number;
    }>;
    currentEpoch: () => number;
    end: (error: Error) => void;
};
export default makeBusinessSocket;
